{"version":3,"file":"static/webpack/static/development/pages/index.js.81710262072e97412524.hot-update.js","sources":["webpack:///./src/index.ts"],"sourcesContent":["import { oneOfType, string, number, oneOf } from 'prop-types';\nimport { CSSObject } from 'styled-components';\nimport * as CSS from 'csstype';\n\nexport const compose = <P extends {}>(\n  ...args: ((p: P) => CSSObject)[]\n): ((p: P) => CSSObject) => {\n  return p => {\n    const result = args.reduce((acc, arg) => ({ ...acc, ...arg(p) }), {});\n    console.log({ result });\n    return result;\n  };\n};\n\nexport const combine = <\n  P1,\n  P2,\n  P3,\n  P4,\n  P5,\n  P6,\n  P7,\n  P8,\n  P9,\n  P10,\n  P11,\n  P12,\n  P13,\n  P14,\n  P15\n>(\n  p1: (p: P1) => FlattenSimpleInterpolation,\n  p2: (p: P2) => FlattenSimpleInterpolation,\n  p3?: (p: P3) => FlattenSimpleInterpolation,\n  p4?: (p: P4) => FlattenSimpleInterpolation,\n  p5?: (p: P5) => FlattenSimpleInterpolation,\n  p6?: (p: P6) => FlattenSimpleInterpolation,\n  p7?: (p: P7) => FlattenSimpleInterpolation,\n  p8?: (p: P8) => FlattenSimpleInterpolation,\n  p9?: (p: P9) => FlattenSimpleInterpolation,\n  p10?: (p: P10) => FlattenSimpleInterpolation,\n  p11?: (p: P11) => FlattenSimpleInterpolation,\n  p12?: (p: P12) => FlattenSimpleInterpolation,\n  p13?: (p: P13) => FlattenSimpleInterpolation,\n  p14?: (p: P14) => FlattenSimpleInterpolation,\n  p15?: (p: P15) => FlattenSimpleInterpolation,\n) => {\n  const atomics = [\n    p1,\n    p2,\n    p3,\n    p4,\n    p5,\n    p6,\n    p7,\n    p8,\n    p9,\n    p10,\n    p11,\n    p12,\n    p13,\n    p14,\n    p15,\n  ].filter(Boolean);\n  return (\n    props: P1 &\n      P2 &\n      P3 &\n      P4 &\n      P5 &\n      P6 &\n      P7 &\n      P8 &\n      P9 &\n      P10 &\n      P11 &\n      P12 &\n      P13 &\n      P14 &\n      P15,\n  ) => {\n    return atomics\n      .map(atomic => atomic(props))\n      .flat(1)\n      .filter(Boolean);\n  };\n};\n\n// export const combine = <P>(\n//   ...atomics: Array<(p: Partial<P>) => FlattenSimpleInterpolation>\n// ): ((p: P) => FlattenSimpleInterpolation) => {\n//   return props => {\n//     return atomics\n//       .map(atomic => atomic(props))\n//       .flat(1)\n//       .filter(Boolean);\n//   };\n// };\n\ntype Aliases = {\n  p: CSSObject['padding'];\n  pl: CSSObject['paddingLeft'];\n  pr: CSSObject['paddingRight'];\n  pt: CSSObject['paddingTop'];\n  pb: CSSObject['paddingBottom'];\n  m: CSSObject['margin'];\n  ml: CSSObject['marginLeft'];\n  mr: CSSObject['marginRight'];\n  mt: CSSObject['marginTop'];\n  mb: CSSObject['marginBottom'];\n  o: CSSObject['opacity'];\n  d: CSSObject['display'];\n  w: CSSObject['width'];\n  h: CSSObject['height'];\n  direction: CSSObject['flexDirection'];\n  align: CSSObject['alignItems'];\n  justify: CSSObject['justifyContent'];\n  wrap: CSSObject['flexWrap'];\n  grow: CSSObject['flexGrow'];\n  shrink: CSSObject['flexShrink'];\n  basis: CSSObject['flexBasis'];\n  flow: CSSObject['flexFlow'];\n  area: CSSObject['gridArea'];\n  autoColumns: CSSObject['gridAutoColumns'];\n  autoFlow: CSSObject['gridAutoFlow'];\n  autoRows: CSSObject['gridAutoRows'];\n  columnEnd: CSSObject['gridColumnEnd'];\n  columnGap: CSSObject['gridColumnGap'];\n  columnStart: CSSObject['gridColumnStart'];\n  column: CSSObject['gridColumn'];\n  gap: CSSObject['gridGap'];\n  rowEnd: CSSObject['gridRowEnd'];\n  rowGap: CSSObject['gridRowGap'];\n  rowStart: CSSObject['gridRowStart'];\n  row: CSSObject['gridRow'];\n  areas: CSSObject['gridTemplateAreas'];\n  columns: CSSObject['gridTemplateColumns'];\n  rows: CSSObject['gridTemplateRows'];\n  template: CSSObject['gridTemplate'];\n  c: CSSObject['color'];\n  bg: CSSObject['background'];\n};\n\ntype AtomicCSSObject = {\n  [key in keyof CSSObject]: CSSObject[key] | ThemeAccessor;\n} &\n  {\n    [key in keyof Partial<Aliases>]: CSSObject[key] | ThemeAccessor;\n  };\n\nconst aliases: { [key in keyof CSSObject]: keyof Aliases } = {\n  padding: 'p',\n  paddingLeft: 'pl',\n  paddingRight: 'pr',\n  paddingTop: 'pt',\n  paddingBottom: 'pb',\n  margin: 'm',\n  marginLeft: 'ml',\n  marginRight: 'mr',\n  marginTop: 'mt',\n  marginBottom: 'mb',\n  opacity: 'o',\n  display: 'd',\n  width: 'w',\n  height: 'h',\n  flexDirection: 'direction',\n  alignItems: 'align',\n  justifyContent: 'justify',\n  flexWrap: 'wrap',\n  flexGrow: 'grow',\n  flexShrink: 'shrink',\n  flexBasis: 'basis',\n  flexFlow: 'flow',\n  gridArea: 'area',\n  gridAutoColumns: 'autoColumns',\n  gridAutoFlow: 'autoFlow',\n  gridAutoRows: 'autoRows',\n  gridColumnEnd: 'columnEnd',\n  gridColumnGap: 'columnGap',\n  gridColumnStart: 'columnStart',\n  gridColumn: 'column',\n  gridGap: 'gap',\n  gridRowEnd: 'rowEnd',\n  gridRowGap: 'rowGap',\n  gridRowStart: 'rowStart',\n  gridRow: 'row',\n  gridTemplateAreas: 'areas',\n  gridTemplateColumns: 'columns',\n  gridTemplateRows: 'rows',\n  gridTemplate: 'template',\n  background: 'bg',\n  color: 'c',\n};\n\nexport type ThemedProps<T> = { theme: T };\n\nexport type ThemeAccessor<T = {}, P extends ThemedProps<T> = { theme: T }> = (\n  props: P,\n) => T[keyof T];\n\nconst isThemeAccessor = <T = {}, P extends { theme: T } = { theme: T }>(\n  candidate: unknown,\n): candidate is ThemeAccessor<T, P> => {\n  return typeof candidate === 'function';\n};\n\nconst hasTheme = <T = {}>(props: any): props is ThemedProps<T> => {\n  return typeof props.theme === 'object';\n};\n\nconst getProperty = <P extends AtomicCSSObject>(\n  props: P,\n  name: keyof CSSObject,\n) => {\n  const alias = aliases[name];\n  const variable = props[name] || (alias && props[alias]);\n  if (typeof variable === 'object') {\n    throw new Error(`getProperty does not support nested objects.`);\n  }\n  if (isThemeAccessor(variable)) {\n    if (!hasTheme(props)) {\n      throw new Error(\n        `getProperty tried to access props.theme and got undefined. Try adding a ThemeProvider.`,\n      );\n    }\n    return variable(props);\n  }\n  return variable;\n};\n\nconst toPx = (value?: string | number): string | undefined =>\n  typeof value === 'undefined'\n    ? undefined\n    : typeof value === 'string'\n    ? value\n    : `${value}px`;\n\nexport const base = <P extends ThemedProps<any> = ThemedProps<any>>(\n  css: AtomicCSSObject,\n): ((p: P) => FlattenSimpleInterpolation) => {\n  return props => {\n    const properties: CSSObject = Object.keys(css).reduce((obj, key) => {\n      const property = getProperty({ ...props, ...css }, key);\n      return { ...obj, [key]: property };\n    }, {});\n    return interpolate(properties);\n  };\n};\n\nexport const variant = <\n  V extends string,\n  P extends ThemedProps<any> & { variant: V } = { variant: V; theme: any }\n>(\n  name: V,\n  css: AtomicCSSObject,\n): ((p: P) => FlattenSimpleInterpolation) => {\n  return props => {\n    if (props.variant === name) {\n      return base(css)(props);\n    }\n    return [];\n  };\n};\n\nexport const is = <K, P extends { [key: K]: string } & ThemedProps<any>>(\n  name: keyof P,\n  css: CSSObject,\n): ((p: P) => FlattenSimpleInterpolation) => {\n  return props => {\n    if (props[name]) {\n      return base(css)(props);\n    }\n    return [];\n  };\n};\n\nconst globalsNumberType = oneOfType([\n  number,\n  // This looks weird but it's the only way to make TS happy with inferred propTypes\n  oneOf<CSS.GlobalsNumber>([\n    '-moz-initial',\n    'inherit',\n    'initial',\n    'revert',\n    'unset',\n  ]),\n]);\n\nexport type PaddingProps = {\n  padding?: CSS.PaddingProperty<string | number>;\n  p?: CSS.PaddingProperty<string | number>;\n  paddingLeft?: CSS.PaddingLeftProperty<string | number>;\n  pl?: CSS.PaddingLeftProperty<string | number>;\n  paddingRight?: CSS.PaddingRightProperty<string | number>;\n  pr?: CSS.PaddingRightProperty<string | number>;\n  paddingTop?: CSS.PaddingTopProperty<string | number>;\n  pt?: CSS.PaddingTopProperty<string | number>;\n  paddingBottom?: CSS.PaddingBottomProperty<string | number>;\n  pb?: CSS.PaddingBottomProperty<string | number>;\n};\n\nexport const paddingPropTypes = {\n  padding: oneOfType([string, number]),\n  p: oneOfType([string, number]),\n  paddingLeft: oneOfType([string, number]),\n  pl: oneOfType([string, number]),\n  paddingRight: oneOfType([string, number]),\n  pr: oneOfType([string, number]),\n  paddingTop: oneOfType([string, number]),\n  pt: oneOfType([string, number]),\n  paddingBottom: oneOfType([string, number]),\n  pb: oneOfType([string, number]),\n};\n\nexport const padding = <P extends PaddingProps>(props: P) => {\n  const padding = toPx(getProperty(props, 'padding'));\n  const paddingLeft = toPx(getProperty(props, 'paddingLeft'));\n  const paddingRight = toPx(getProperty(props, 'paddingRight'));\n  const paddingTop = toPx(getProperty(props, 'paddingTop'));\n  const paddingBottom = toPx(getProperty(props, 'paddingBottom'));\n  return interpolate({\n    padding,\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    paddingBottom,\n  });\n};\n\nexport type MarginProps = {\n  margin?: CSS.MarginProperty<string | number>;\n  m?: CSS.MarginProperty<string | number>;\n  marginLeft?: CSS.MarginLeftProperty<string | number>;\n  ml?: CSS.MarginLeftProperty<string | number>;\n  marginRight?: CSS.MarginRightProperty<string | number>;\n  mr?: CSS.MarginRightProperty<string | number>;\n  marginTop?: CSS.MarginTopProperty<string | number>;\n  mt?: CSS.MarginTopProperty<string | number>;\n  marginBottom?: CSS.MarginBottomProperty<string | number>;\n  mb?: CSS.MarginBottomProperty<string | number>;\n};\n\nexport const marginPropTypes = {\n  margin: oneOfType([string, number]),\n  m: oneOfType([string, number]),\n  marginLeft: oneOfType([string, number]),\n  ml: oneOfType([string, number]),\n  marginRight: oneOfType([string, number]),\n  mr: oneOfType([string, number]),\n  marginTop: oneOfType([string, number]),\n  mt: oneOfType([string, number]),\n  marginBottom: oneOfType([string, number]),\n  mb: oneOfType([string, number]),\n};\n\nexport const margin = <P extends MarginProps>(props: P) => {\n  const margin = toPx(getProperty(props, 'margin'));\n  const marginLeft = toPx(getProperty(props, 'marginLeft'));\n  const marginRight = toPx(getProperty(props, 'marginRight'));\n  const marginTop = toPx(getProperty(props, 'marginTop'));\n  const marginBottom = toPx(getProperty(props, 'marginBottom'));\n  return interpolate({\n    margin,\n    marginLeft,\n    marginRight,\n    marginTop,\n    marginBottom,\n  });\n};\n\nexport type SpacingProps = PaddingProps & MarginProps;\n\nexport const spacingPropTypes = { ...marginPropTypes, ...paddingPropTypes };\n\nexport const spacing = combine(margin, padding);\n\nexport type OpacityProps = {\n  opacity?: CSS.OpacityProperty;\n  o?: CSS.OpacityProperty;\n};\n\nexport const opacityPropTypes = {\n  opacity: oneOfType([string, number]),\n  o: oneOfType([string, number]),\n};\n\nexport const opacity = <P extends OpacityProps>(props: P) => {\n  const opacity = getProperty(props, 'opacity');\n  return interpolate({ opacity });\n};\n\nexport type DisplayProps = {\n  display?: CSS.DisplayProperty;\n  d?: CSS.DisplayProperty;\n};\n\nexport const displayPropTypes = {\n  display: string,\n  d: string,\n};\n\nexport const display = <P extends DisplayProps>(props: P) => {\n  const display = getProperty(props, 'display');\n  return interpolate({ display });\n};\n\nexport type SizeProps = {\n  width?: number | string;\n  w?: number | string;\n  height?: number | string;\n  h?: number | string;\n};\n\nexport const sizePropTypes = {\n  width: oneOfType([number, string]),\n  w: oneOfType([number, string]),\n  height: oneOfType([number, string]),\n  h: oneOfType([number, string]),\n};\n\nexport const size = <P extends SizeProps>(props: P) => {\n  const width = toPx(getProperty(props, 'width'));\n  const height = toPx(getProperty(props, 'height'));\n  return interpolate({ width, height });\n};\n\nexport type FlexProps = {\n  flex?: CSS.FlexProperty<string | number>;\n  order?: CSS.GlobalsNumber;\n  flexDirection?: CSS.FlexDirectionProperty;\n  direction?: CSS.FlexDirectionProperty;\n  alignItems?: CSS.AlignItemsProperty;\n  align?: CSS.AlignItemsProperty;\n  justifyContent?: CSS.JustifyContentProperty;\n  justify?: CSS.JustifyContentProperty;\n  flexWrap?: CSS.FlexWrapProperty;\n  wrap?: CSS.FlexWrapProperty;\n  flexGrow?: CSS.GlobalsNumber;\n  grow?: CSS.GlobalsNumber;\n  flexShrink?: CSS.GlobalsNumber;\n  shrink?: CSS.GlobalsNumber;\n  flexBasis?: CSS.FlexBasisProperty<string | number>;\n  basis?: CSS.FlexBasisProperty<string | number>;\n  alignContent?: CSS.AlignContentProperty;\n  flexFlow?: CSS.FlexFlowProperty;\n  flow?: CSS.FlexFlowProperty;\n};\n\nconst flexDirectionType = oneOf<CSS.FlexDirectionProperty>([\n  '-moz-initial',\n  'inherit',\n  'initial',\n  'revert',\n  'unset',\n  'column',\n  'column-reverse',\n  'row',\n  'row-reverse',\n]);\n\nconst flexWrapType = oneOf<CSS.FlexWrapProperty>([\n  'wrap',\n  '-moz-initial',\n  'inherit',\n  'initial',\n  'revert',\n  'unset',\n  'nowrap',\n  'wrap-reverse',\n]);\n\nexport const flexPropTypes = {\n  flex: oneOfType([string, number]),\n  order: globalsNumberType,\n  flexDirection: flexDirectionType,\n  direction: flexDirectionType,\n  alignItems: string,\n  align: string,\n  justifyContent: string,\n  justify: string,\n  flexWrap: flexWrapType,\n  wrap: flexWrapType,\n  flexGrow: globalsNumberType,\n  grow: globalsNumberType,\n  flexShrink: globalsNumberType,\n  shrink: globalsNumberType,\n  flexBasis: string,\n  basis: oneOfType([string, number]),\n  alignContent: string,\n  flexFlow: string,\n  flow: string,\n};\n\nexport const flex = <P extends FlexProps>(props: P) => {\n  const flex = getProperty(props, 'flex');\n  const order = getProperty(props, 'order');\n  const flexDirection = getProperty(props, 'flexDirection');\n  const alignItems = getProperty(props, 'alignItems');\n  const justifyContent = getProperty(props, 'justifyContent');\n  const flexWrap = getProperty(props, 'flexWrap');\n  const flexGrow = getProperty(props, 'flexGrow');\n  const flexShrink = getProperty(props, 'flexShrink');\n  const flexBasis = getProperty(props, 'flexBasis');\n  const alignContent = getProperty(props, 'alignContent');\n  const flexFlow = getProperty(props, 'flexFlow');\n  return interpolate({\n    flex,\n    order,\n    flexDirection,\n    alignItems,\n    justifyContent,\n    flexWrap,\n    flexGrow,\n    flexShrink,\n    flexBasis,\n    alignContent,\n    flexFlow,\n  });\n};\n\nexport type GridProps = {\n  grid?: CSS.GridProperty;\n  gridArea?: CSS.GridAreaProperty;\n  area?: CSS.GridAreaProperty;\n  gridAutoColumns?: CSS.GridAutoColumnsProperty<string | number>;\n  autoColumns?: CSS.GridAutoColumnsProperty<string | number>;\n  gridAutoFlow?: CSS.GridAutoFlowProperty;\n  autoFlow?: CSS.GridAutoFlowProperty;\n  gridAutoRows?: CSS.GridAutoRowsProperty<string | number>;\n  autoRows?: CSS.GridAutoRowsProperty<string | number>;\n  gridColumnEnd?: CSS.GridColumnEndProperty;\n  columnEnd?: CSS.GridColumnEndProperty;\n  gridColumnGap?: CSS.GridColumnGapProperty<string | number>;\n  columnGap?: CSS.GridColumnGapProperty<string | number>;\n  gridColumnStart?: CSS.GridColumnStartProperty;\n  columnStart?: CSS.GridColumnStartProperty;\n  gridColumn?: CSS.GridColumnProperty;\n  column?: CSS.GridColumnProperty;\n  gridGap?: CSS.GridGapProperty<string | number>;\n  gap?: CSS.GridGapProperty<string | number>;\n  gridRowEnd?: CSS.GridRowEndProperty;\n  rowEnd?: CSS.GridRowEndProperty;\n  gridRowGap?: CSS.GridRowGapProperty<string | number>;\n  rowGap?: CSS.GridRowGapProperty<string | number>;\n  gridRowStart?: CSS.GridRowStartProperty;\n  rowStart?: CSS.GridRowStartProperty;\n  gridRow?: CSS.GridRowProperty;\n  row?: CSS.GridRowProperty;\n  gridTemplateAreas?: CSS.GridTemplateAreasProperty;\n  areas?: CSS.GridTemplateAreasProperty;\n  gridTemplateColumns?: CSS.GridTemplateColumnsProperty<string | number>;\n  columns?: CSS.GridTemplateColumnsProperty<string | number>;\n  gridTemplateRows?: CSS.GridTemplateRowsProperty<string | number>;\n  rows?: CSS.GridTemplateRowsProperty<string | number>;\n  gridTemplate?: CSS.GridTemplateProperty;\n  template?: CSS.GridTemplateProperty;\n};\n\nexport const gridPropTypes = {\n  grid: string,\n  gridArea: oneOfType([string, number]),\n  area: oneOfType([string, number]),\n  gridAutoColumns: oneOfType([string, number]),\n  autoColumns: oneOfType([string, number]),\n  gridAutoFlow: string,\n  autoFlow: string,\n  gridAutoRows: oneOfType([string, number]),\n  autoRows: oneOfType([string, number]),\n  gridColumnEnd: oneOfType([string, number]),\n  columnEnd: oneOfType([string, number]),\n  gridColumnGap: oneOfType([string, number]),\n  columnGap: oneOfType([string, number]),\n  gridColumnStart: oneOfType([string, number]),\n  columnStart: oneOfType([string, number]),\n  gridColumn: oneOfType([string, number]),\n  column: oneOfType([string, number]),\n  gridGap: oneOfType([string, number]),\n  gap: oneOfType([string, number]),\n  gridRowEnd: oneOfType([string, number]),\n  rowEnd: oneOfType([string, number]),\n  gridRowGap: oneOfType([string, number]),\n  rowGap: oneOfType([string, number]),\n  gridRowStart: oneOfType([string, number]),\n  rowStart: oneOfType([string, number]),\n  gridRow: oneOfType([string, number]),\n  row: oneOfType([string, number]),\n  gridTemplateAreas: string,\n  areas: string,\n  gridTemplateColumns: oneOfType([string, number]),\n  columns: oneOfType([string, number]),\n  gridTemplateRows: oneOfType([string, number]),\n  rows: oneOfType([string, number]),\n  gridTemplate: string,\n  template: string,\n};\n\nexport const grid = <P extends GridProps>(props: P) => {\n  return interpolate({\n    grid: getProperty(props, 'grid'),\n    gridArea: getProperty(props, 'gridArea'),\n    gridAutoColumns: getProperty(props, 'gridAutoColumns'),\n    gridAutoFlow: getProperty(props, 'gridAutoFlow'),\n    gridAutoRows: getProperty(props, 'gridAutoRows'),\n    gridColumnEnd: getProperty(props, 'gridColumnEnd'),\n    gridColumnGap: toPx(getProperty(props, 'gridColumnGap')),\n    gridColumnStart: getProperty(props, 'gridColumnStart'),\n    gridColumn: getProperty(props, 'gridColumn'),\n    gridGap: toPx(getProperty(props, 'gridGap')),\n    gridRowEnd: getProperty(props, 'gridRowEnd'),\n    gridRowGap: toPx(getProperty(props, 'gridRowGap')),\n    gridRowStart: getProperty(props, 'gridRowStart'),\n    gridRow: getProperty(props, 'gridRow'),\n    gridTemplateAreas: getProperty(props, 'gridTemplateAreas'),\n    gridTemplateColumns: getProperty(props, 'gridTemplateColumns'),\n    gridTemplateRows: getProperty(props, 'gridTemplateRows'),\n    gridTemplate: getProperty(props, 'gridTemplate'),\n  });\n};\n\nexport type TypographyProps = {\n  fontFamily?: CSS.FontFamilyProperty;\n  fontSize?: CSS.FontSizeProperty<string | number>;\n  fontWeight?: CSS.FontWeightProperty;\n  lineHeight?: CSS.LineHeightProperty<string | number>;\n  letterSpacing?: CSS.LetterSpacingProperty<string | number>;\n  textAlign?: CSS.TextAlignProperty;\n  fontStyle?: CSS.FontStyleProperty;\n};\n\nconst fontWeightType = oneOfType([\n  number,\n  oneOf<CSS.FontWeightProperty>([\n    '-moz-initial',\n    'inherit',\n    'initial',\n    'revert',\n    'unset',\n    'normal',\n    'bold',\n    'bolder',\n    'lighter',\n  ]),\n]);\n\nconst textAlignType = oneOf<CSS.TextAlignProperty>([\n  '-moz-initial',\n  'inherit',\n  'initial',\n  'revert',\n  'unset',\n  'center',\n  'end',\n  'justify',\n  'left',\n  'match-parent',\n  'right',\n  'start',\n]);\n\nexport const typographyPropTypes = {\n  fontFamily: string,\n  fontSize: oneOfType([string, number]),\n  fontWeight: fontWeightType,\n  lineHeight: oneOfType([string, number]),\n  letterSpacing: oneOfType([string, number]),\n  textAlign: textAlignType,\n  fontStyle: string,\n};\n\nexport const typography = <P extends TypographyProps>(props: P) => {\n  return interpolate({\n    fontFamily: getProperty(props, 'fontFamily'),\n    fontSize: toPx(getProperty(props, 'fontSize')),\n    fontWeight: getProperty(props, 'fontWeight'),\n    lineHeight: toPx(getProperty(props, 'lineHeight')),\n    letterSpacing: toPx(getProperty(props, 'letterSpacing')),\n    textAlign: getProperty(props, 'textAlign'),\n    fontStyle: getProperty(props, 'fontStyle'),\n  });\n};\n\nexport type ColorProps = {\n  color?: CSS.ColorProperty;\n  c?: CSS.ColorProperty;\n  backgroundColor?: CSS.BackgroundColorProperty;\n  bg?: CSS.BackgroundColorProperty;\n};\n\nexport const colorPropTypes = {\n  color: string,\n  c: string,\n  backgroundColor: string,\n  bg: string,\n};\n\nexport const color = <P extends ColorProps>(props: P) => {\n  return interpolate({\n    color: getProperty(props, 'color'),\n    backgroundColor: getProperty(props, 'backgroundColor'),\n  });\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAIA;AAEA;AADA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAiCA;AAiBA;AAiBA;AACA;AAAA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AACA;AAiDA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAGA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAIA;AAEA;AAOA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAOA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AASA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAwBA;AAYA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;AAsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;AAYA;AAeA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AASA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAFA;AAIA;;;;A","sourceRoot":""}